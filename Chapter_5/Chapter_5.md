Существует два основных способа реализации одновременного выполнения задач в Python – ветвление процессов (forks) и порожденные потоки (threads) выполнения.

Ветвление процессов
Традиционный способ организации параллельных вычислений. Самый простой способ запуска независимых программ, как отличных, так и не отличных от вызывающей программы. Прием ветвления основан на понятии копирования программ: когда программа вызывает процедуру ветвления, операционная система создает в памяти новую копию этой программы и запускает ее параллельно оригиналу.

После операции ветвления исходный экземпляр программы называется родительским процессом, а копия, созданная с помощью функции os.fork, называется дочерним процессом. Родитель может воспроизвести любое число потомков, а потомки могут создать собственные дочерние процессы – все ответвленные процессы выполняются независимо и параллельно под управлением операционной системы, и дочерние процессы могут продолжать выполняться даже после завершения родительского процесса.

Потоки выполнения
В двух словах, механизм потоков выполнения позволяет запустить функцию (или вызываемый объект другого типа) параллельно основной программе. Иногда их называют «облегченными процессами», потому что они работают параллельно, подобно дочерним процессам, но выполняются в рамках одного и того же процесса. Процессы обычно используются для запуска независимых программ, а потоки выполнения – для решения таких задач, как неблокирующий ввод, и для выполнения продолжительных заданий в программах с графическим интерфейсом.

Поскольку потоки выполняются в одном процессе, они используют общую глобальную память процесса. Благодаря этому
потоки могут просто и естественно взаимодействовать друг с другом путем чтения и записи данных в глобальной памяти, доступной всем потокам выполнения. Для программиста на языке Python это означает, что глобальные переменные, объекты и их атрибуты и такие компоненты, как импортированные модули, совместно используются всеми потоками выполнения в программе – если, например, в одном потоке выполнения присваивается значение глобальной переменной, ее новое значение увидят все другие потоки выполнения.

Потоки выполнения предназначены для запуска функций (точнее, любого вызываемого объекта, включая связанные и несвязанные методы), выполняющихся параллельно с основной программой.

_thread.start_new_thread - эта функция принимает функцию (или другой вызываемый объект) и кортеж аргументов, и запускает новый поток выполнения, в котором будет вызвана указанная функция с переданными аргументами.

особенно полезными оказываются связанные методы – так как они хранят в себе и ссылку на функцию, и ссылку на экземпляр объекта, то они обладают доступом к информации о состоянии и методам класса, которые могут использовать в процессе выполнения внутри потока.

Если смотреть глубже – так как все потоки выполняются в рамках одного и того же процесса, то связанные методы, выполняемые в отдельных потоках, имеют доступ к оригинальному экземпляру объекта, а не к его копии. Следовательно, любые изменения, выполненные в потоке, автоматически будут видимы для всех остальных потоков. Кроме того, связанные методы экземпляров классов, как вызываемые объекты, могут использоваться вместо простых функций, поэтому использо-
вание их в потоках выполнения не влечет никаких сложностей.

Если главный поток завершится раньше, все порожденные потоки будут немедленно завершены. Этим потоки выполнения отличаются от процессов, где дочерние процессы продолжают работать после завершения родительского процесса.

Синхронизация доступа к глобальным объектам и переменным
В модуле _thread имеются собственные простые в использовании инструменты синхронизации потоков, выполняющих операции
с совместно используемыми объектами. Эти инструменты основаны на понятии блокировки – чтобы изменить совместно используемый объект, потоки приобретают блокировку, производят требуемые изменения и освобождают блокировку для использования в других потоках выполнения. Интерпретатор гарантирует, что в каждый конкретный момент времени только один поток выполнения будет владеть блокировкой, – если запрос на приобретение блокировки поступит в тот момент,
когда она удерживается некоторым потоком, запросивший поток будет приостановлен до того момента, пока блокировка не будет освобождена.


Анонимные каналы
Каналы, как механизм взаимодействия программ, реализуются операционной системой, а стандартная библиотека
Python лишь обеспечивает доступ к ним. Каналы – это однонаправленные потоки ввода-вывода, по своему действию напоминающие буфер в совместно используемой памяти, интерфейс которого с обеих сторон похож на простой файл.
В самом типичном случае использования одна программа пишет данные с одного конца канала, а вторая читает их с другого конца. Каждая из программ видит только свой конец канала и обрабатывает его с помощью обычных функций для работы с файлами.

Основы сокетов
 - Подобно именованным каналам, сокеты являются глобальным для компьютера механизмом – они не требуют наличия памяти, совместно используемой потоками выполнения или процессами, и поэтому могут использоваться независимыми программами.

 - В отличие от именованных каналов, сокеты идентифицируются по номеру порта, а не по имени файла в файловой системе,
 при работе с ними используется совершенно иной API, не похожий на файлы, тем не менее имеется возможность обертывать их объектами файлов.
 
